syntax = "proto2";

package object_detection.protos;

import "object_detection/protos/image_resizer.proto";
import "object_detection/protos/anchor_generator.proto";
import "object_detection/protos/hyperparams.proto";


message IJCAIDetector {
    // Number of classes to predict.
    optional int32 num_classes = 1;
    // Image resizer for preprocessing the input image.
    optional ImageResizer image_resizer = 2;
    // Feature extractor config.
    optional IJCAIFeatureExtractor feature_extractor = 3;
    // Depthwise Separable config

    //HyperParams
    optional Hyperparams depthwise_hyperparams = 4;
    // If use depthwise separable convolution
    optional bool use_depthwise = 5 [default = true];
    // Number of filters to use
    optional int32 numfilters = 6 [default = 1024];
    // Depth multiplier
    optional int32 depth_multiplier = 7 [default = 1];

    //Semantic Segmentation Config
    optional SegmentationLayer segmentation_layer=8;
    
    // Anchor generator to compute anchors.
    optional AnchorGenerator first_stage_anchor_generator = 9;

}

message IJCAIFeatureExtractor {
    // Type of IJCAIDetector model (e.g., 'faster_rcnn_resnet101';
    // See builders/model_builder.py for expected types).
    optional string type = 1;

    // Output stride of extracted feature map.
    optional int32 output_stride = 2 [default = 16];

    // Whether to update batch norm parameters during training or not.
    // When training with a relative large batch size (e.g. 8), it could be
    // desirable to enable batch norm update.
    optional bool batch_norm_trainable = 3 [default = false];
}

message SegmentationLayer{
    repeated SemanticFilter semantic_filter=1;
}

message SemanticFilter{
    optional int32 atrous_rate=1[default=1];
    optional int32 numfilters=2[default=256];
    optional Hyperparams semantic_hyperparams=3;
}

